<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NovelVoice - AI Audiobook Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f2937;
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 h-screen overflow-hidden">
    <div id="app" class="flex h-full">
        <!-- Sidebar -->
        <div
            class="w-80 bg-gray-800 border-r border-gray-700 flex flex-col p-6 space-y-6 overflow-y-auto shrink-0 z-20">
            <h1 class="text-2xl font-bold text-blue-400 flex items-center gap-2 cursor-pointer"
                @click="viewMode = 'list'">
                <span>üéôÔ∏è</span> NovelVoice
            </h1>

            <!-- Configuration -->
            <div class="space-y-4">
                <div class="flex items-center justify-between">
                    <h2 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">ÈÖçÈü≥ËÆæÁΩÆ</h2>
                    <div class="flex items-center gap-2">
                        <button @click="reloadConfig" :disabled="reloadingConfig"
                            class="text-xs flex items-center gap-1 transition-colors"
                            :class="reloadingConfig ? 'text-gray-600 cursor-not-allowed' : 'text-blue-500 hover:text-blue-400'"
                            title="‰ªéÁ£ÅÁõòÈáçÊñ∞Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂">
                            <svg v-if="!reloadingConfig" class="w-4 h-4" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                            <svg v-else class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                    stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor"
                                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                </path>
                            </svg>
                            <span>{{ reloadingConfig ? 'ÈáçËΩΩ‰∏≠' : 'ÈáçËΩΩÈÖçÁΩÆ' }}</span>
                        </button>
                        <button @click="resetConfig"
                            class="text-xs text-gray-500 hover:text-white flex items-center gap-1 transition-colors"
                            title="ÈáçÁΩÆÂèÇÊï∞">
                            <span>‚Ü∫</span> ÈáçÁΩÆ
                        </button>
                    </div>
                </div>

                <!-- Voice -->
                <div>
                    <label class="block text-sm mb-1 text-gray-300">ÂèëÈü≥‰∫∫ (Voice)</label>
                    <select v-model="config.voice"
                        class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                        <option v-for="v in voices" :key="v.ShortName" :value="v.ShortName">
                            {{ v.Description || `[${v.Style}] ${v.ShortName.split('-').pop().replace('Neural','')}
                            (${v.Gender})` }}
                        </option>
                    </select>
                </div>

                <!-- Rate -->
                <div>
                    <div class="flex justify-between text-sm mb-1">
                        <label class="text-gray-300">ËØ≠ÈÄü (Rate)</label>
                        <div class="flex items-center gap-1">
                            <input type="number" v-model="rateVal"
                                class="w-12 bg-transparent text-right outline-none text-blue-400 border-b border-gray-600 focus:border-blue-400 text-xs font-mono">
                            <span class="text-blue-400 text-xs">%</span>
                        </div>
                    </div>
                    <input type="range" min="-100" max="300" step="5" v-model="rateVal"
                        class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Volume -->
                <div>
                    <div class="flex justify-between text-sm mb-1">
                        <label class="text-gray-300">Èü≥Èáè (Volume)</label>
                        <div class="flex items-center gap-1">
                            <input type="number" v-model="volumeVal"
                                class="w-12 bg-transparent text-right outline-none text-blue-400 border-b border-gray-600 focus:border-blue-400 text-xs font-mono">
                            <span class="text-blue-400 text-xs">%</span>
                        </div>
                    </div>
                    <input type="range" min="-100" max="100" step="5" v-model="volumeVal"
                        class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Pitch -->
                <div>
                    <div class="flex justify-between text-sm mb-1">
                        <label class="text-gray-300">Èü≥Ë∞É (Pitch)</label>
                        <div class="flex items-center gap-1">
                            <input type="number" v-model="pitchVal"
                                class="w-12 bg-transparent text-right outline-none text-blue-400 border-b border-gray-600 focus:border-blue-400 text-xs font-mono">
                            <span class="text-blue-400 text-xs">Hz</span>
                        </div>
                    </div>
                    <input type="range" min="-50" max="50" step="1" v-model="pitchVal"
                        class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>

                <div id="app" class="flex flex-col h-full">
                    <!-- Top Navigation Bar -->
                    <div
                        class="bg-gray-800 border-b border-gray-700 px-6 py-3 flex items-center justify-between shrink-0">
                        <div class="flex items-center gap-4">
                            <h1 class="text-xl font-bold text-blue-400 flex items-center gap-2 cursor-pointer"
                                @click="viewMode = 'list'">
                                <span>üéôÔ∏è</span> NovelVoice
                            </h1>
                            <span class="text-xs text-gray-500">AI ÊúâÂ£∞‰π¶ÁîüÊàêÂô®</span>
                        </div>
                        <div class="flex items-center gap-4">
                            <a href="https://github.com/skyshenma/NovelVoice" target="_blank"
                                class="text-sm text-gray-400 hover:text-blue-400 flex items-center gap-1 transition-colors">
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                                    <path
                                        d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                                </svg>
                                GitHub
                            </a>
                            <a href="https://github.com/skyshenma/NovelVoice/blob/main/README.md" target="_blank"
                                class="text-sm text-gray-400 hover:text-blue-400 transition-colors">
                                üìñ ÊñáÊ°£
                            </a>
                            <a href="https://hub.docker.com/r/skyshenma2024/novelvoice" target="_blank"
                                class="text-sm text-gray-400 hover:text-blue-400 flex items-center gap-1 transition-colors">
                                üê≥ Docker Hub
                            </a>
                        </div>
                    </div>

                    <div class="flex flex-1 overflow-hidden">
                        <!-- Sidebar -->
                        <div class="w-80 bg-gray-800 border-r border-gray-700 flex flex-col shrink-0">
                            <!-- Upload Section - ÁΩÆÈ°∂ -->
                            <div class="p-4 border-b border-gray-700">
                                <h2 class="text-sm font-semibold text-gray-400 mb-3 uppercase tracking-wider">üìö ÂØºÂÖ•‰π¶Á±ç
                                </h2>
                                <div class="border-2 border-dashed border-gray-600 rounded-lg p-4 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-750 transition-colors"
                                    @click="$refs.fileInput.click()" @dragover.prevent @drop.prevent="handleDrop">
                                    <input type="file" ref="fileInput" class="hidden" accept=".txt,.epub"
                                        @change="handleFileSelect">
                                    <p class="text-gray-400 text-sm" v-if="!uploading">ÁÇπÂáªÊàñÊãñÊãΩ‰∏ä‰º† TXT/EPUB</p>
                                    <p class="text-blue-400 text-sm animate-pulse" v-else>Ê≠£Âú®Â§ÑÁêÜ...</p>
                                </div>
                            </div>

                            <!-- Scrollable Config Area -->
                            <div class="flex-1 overflow-y-auto p-4 space-y-4">
                                <!-- Basic TTS Settings -->
                                <div>
                                    <h2
                                        class="text-sm font-semibold text-gray-400 mb-3 uppercase tracking-wider flex items-center justify-between">
                                        üé§ ÈÖçÈü≥ËÆæÁΩÆ
                                        <button @click="reloadConfig"
                                            class="text-xs text-blue-400 hover:text-blue-300 flex items-center gap-1">
                                            üîÑ ÈáçËΩΩÈÖçÁΩÆ
                                        </button>
                                    </h2>
                                    <div class="space-y-3">
                                        <!-- Voice -->
                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300">ÂèëÈü≥‰∫∫ (Voice)</label>
                                            <select v-model="config.voice"
                                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                                                <option v-for="v in voices" :key="v.ShortName" :value="v.ShortName">
                                                    {{ v.Description || `[${v.Style}]
                                                    ${v.ShortName.split('-').pop().replace('Neural','')} (${v.Gender})`
                                                    }}
                                                </option>
                                            </select>
                                        </div>

                                        <!-- Rate -->
                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300 flex justify-between">
                                                <span>ËØ≠ÈÄü (Rate)</span>
                                                <span class="text-blue-400">{{ config.rate }} %</span>
                                            </label>
                                            <input type="range" v-model.number="config.rate" min="-50" max="100"
                                                step="10" class="w-full">
                                        </div>

                                        <!-- Volume -->
                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300 flex justify-between">
                                                <span>Èü≥Èáè (Volume)</span>
                                                <span class="text-blue-400">{{ config.volume }} %</span>
                                            </label>
                                            <input type="range" v-model.number="config.volume" min="-50" max="50"
                                                step="10" class="w-full">
                                        </div>

                                        <!-- Pitch -->
                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300 flex justify-between">
                                                <span>Èü≥Ë∞É (Pitch)</span>
                                                <span class="text-blue-400">{{ config.pitch }} Hz</span>
                                            </label>
                                            <input type="range" v-model.number="config.pitch" min="-50" max="50"
                                                step="10" class="w-full">
                                        </div>

                                        <!-- Threads -->
                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300 flex justify-between">
                                                <span>Âπ∂ÂèëÊï∞ (Threads)</span>
                                                <span class="text-green-400">{{ concurrency }}</span>
                                            </label>
                                            <input type="number" v-model.number="concurrency" min="1" max="10"
                                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                                        </div>
                                    </div>
                                </div>

                                <!-- Advanced Settings - Collapsible -->
                                <div class="border-t border-gray-700 pt-4">
                                    <button @click="showAdvanced = !showAdvanced"
                                        class="w-full flex items-center justify-between text-sm font-semibold text-gray-400 uppercase tracking-wider hover:text-gray-300 transition-colors">
                                        <span>‚öôÔ∏è È´òÁ∫ßËÆæÁΩÆ</span>
                                        <span class="text-lg">{{ showAdvanced ? '‚ñº' : '‚ñ∂' }}</span>
                                    </button>

                                    <div v-show="showAdvanced" class="mt-3 space-y-4">
                                        <!-- Save Config -->
                                        <div>
                                            <button @click="saveConfig" :disabled="savingConfig"
                                                class="w-full bg-green-600 hover:bg-green-500 disabled:bg-gray-700 disabled:text-gray-500 text-white text-sm py-2 rounded transition-colors flex items-center justify-center gap-2">
                                                <span v-if="savingConfig" class="animate-spin">‚è≥</span>
                                                <span v-else>üíæ</span>
                                                {{ savingConfig ? '‰øùÂ≠ò‰∏≠...' : '‰øùÂ≠ò‰∏∫ÈªòËÆ§ÈÖçÁΩÆ' }}
                                            </button>
                                            <p class="text-xs text-gray-500 mt-2">
                                                üí° ‰øùÂ≠òÂêé‰∏ãÊ¨°ÂêØÂä®Êó∂‰ºö‰ΩøÁî®Ëøô‰∫õËÆæÁΩÆ
                                            </p>
                                        </div>

                                        <!-- Preview -->
                                        <div>
                                            <button @click="previewVoice" :disabled="previewing"
                                                class="w-full bg-blue-600 hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-500 text-white text-sm py-2 rounded transition-colors flex items-center justify-center gap-2">
                                                <span v-if="previewing" class="animate-spin">‚è≥</span>
                                                <span v-else>üîä</span>
                                                {{ previewing ? 'ËØïÂê¨‰∏≠...' : 'ËØïÂê¨ÂΩìÂâçÂèëÈü≥‰∫∫' }}
                                            </button>
                                        </div>

                                        <!-- Custom Preview -->
                                        <div>
                                            <h3 class="text-sm font-semibold text-gray-400 mb-2">Ëá™ÂÆö‰πâËØïËØª</h3>
                                            <textarea v-model="customText" placeholder="‰Ω†Â•ΩÔºåÊàëÊòØYunjianÔºåÊÇ®ÂèØ‰ª•‰ª•Ê≠§Êù•ÊµãËØïÊàëËØª„ÄÇ"
                                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none resize-none"
                                                rows="3" maxlength="100"></textarea>
                                            <div class="flex justify-between items-center mt-2">
                                                <span class="text-xs text-gray-500">{{ customText.length }}/100</span>
                                                <button @click="previewCustom"
                                                    :disabled="!customText || customPreviewing"
                                                    class="bg-blue-600 hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-500 text-white text-xs px-3 py-1 rounded transition-colors">
                                                    {{ customPreviewing ? 'ËØïÂê¨‰∏≠...' : '‚ñ∂ ËØïÂê¨' }}
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Bark Notifications - Collapsible -->
                                <div class="border-t border-gray-700 pt-4">
                                    <button @click="showBark = !showBark"
                                        class="w-full flex items-center justify-between text-sm font-semibold text-gray-400 uppercase tracking-wider hover:text-gray-300 transition-colors">
                                        <span>üì± Êé®ÈÄÅÈÄöÁü•</span>
                                        <span class="text-lg">{{ showBark ? '‚ñº' : '‚ñ∂' }}</span>
                                    </button>

                                    <div v-show="showBark" class="mt-3 space-y-3">
                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300">Bark ÊúçÂä°Âô®Âú∞ÂùÄ</label>
                                            <input type="text" v-model="bark.serverUrl"
                                                placeholder="https://api.day.app"
                                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                                        </div>

                                        <div>
                                            <label class="block text-sm mb-1 text-gray-300">Bark Key</label>
                                            <input type="text" v-model="barkConfig.apiKey" placeholder="‰Ω†ÁöÑ Bark Key"
                                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                                        </div>

                                        <div class="flex items-center gap-2">
                                            <input type="checkbox" v-model="barkConfig.enabled" id="barkEnabled"
                                                class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                                            <label for="barkEnabled" class="text-sm text-gray-300">ÂêØÁî®Êé®ÈÄÅÈÄöÁü•</label>
                                        </div>

                                        <button @click="testBark"
                                            :disabled="!barkConfig.enabled || !barkConfig.apiKey || barkTesting"
                                            class="w-full bg-green-600 hover:bg-green-500 disabled:bg-gray-700 disabled:text-gray-500 text-white text-xs py-2 rounded transition-colors flex items-center justify-center gap-2">
                                            <span v-if="barkTesting" class="animate-spin">‚è≥</span>
                                            <span v-else>üîî</span>
                                            {{ barkTesting ? 'ÂèëÈÄÅ‰∏≠...' : 'ÂèëÈÄÅÊµãËØïÈÄöÁü•' }}
                                        </button>

                                        <p class="text-xs text-gray-500 leading-relaxed">
                                            üí° ÊèêÁ§∫ÔºöÂêØÁî®ÂêéÔºå‰ªªÂä°ÂºÄÂßãÂíåÂÆåÊàêÊó∂‰ºöËá™Âä®Êé®ÈÄÅÈÄöÁü•Âà∞‰Ω†ÁöÑÊâãÊú∫
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Main Content Area -->
                        <div class="flex-1 flex flex-col h-full overflow-hidden bg-gray-900 relative">

                            <!-- LIST VIEW -->
                            <div v-if="viewMode === 'list'" class="flex-1 overflow-y-auto p-8">
                                <div class="max-w-4xl mx-auto">
                                    <div class="flex justify-between items-center mb-6">
                                        <h2 class="text-xl font-bold text-gray-100">‰π¶Á±çÂàóË°®</h2>
                                        <button @click="fetchBooks"
                                            class="text-sm text-gray-400 hover:text-white flex items-center gap-1">
                                            üîÑ Âà∑Êñ∞
                                        </button>
                                    </div>

                                    <div class="grid gap-4">
                                        <div v-for="book in books" :key="book.name"
                                            class="bg-gray-800 rounded-lg p-5 border border-gray-700 shadow-lg hover:border-gray-600 transition-all cursor-pointer group"
                                            @click="enterDetail(book)">

                                            <div class="flex justify-between items-start mb-4">
                                                <div>
                                                    <h3
                                                        class="text-lg font-semibold text-white mb-1 group-hover:text-blue-400 transition-colors">
                                                        {{ book.name }}</h3>
                                                    <p class="text-xs text-gray-500 font-mono">{{ book.path }}</p>
                                                </div>
                                                <span :class="statusClass(book.status)"
                                                    class="px-2 py-1 rounded text-xs font-bold uppercase tracking-wide">
                                                    {{ book.status }}
                                                </span>
                                            </div>

                                            <!-- Progress -->
                                            <div class="mb-4">
                                                <div class="flex justify-between text-xs text-gray-400 mb-1">
                                                    <span>{{ book.completed }} / {{ book.total }} Á´†ËäÇ</span>
                                                    <span>{{ progressPercent(book) }}%</span>
                                                </div>
                                                <div class="w-full bg-gray-700 rounded-full h-2 overflow-hidden">
                                                    <div class="bg-blue-500 h-2 rounded-full transition-all duration-500"
                                                        :style="{ width: progressPercent(book) + '%' }"></div>
                                                </div>
                                            </div>

                                            <!-- Quick Start -->
                                            <div class="mt-3 pt-3 border-t border-gray-700 flex items-center gap-2"
                                                @click.stop>
                                                <input type="text" v-model="quickRanges[book.name]"
                                                    placeholder="ËåÉÂõ¥ (Â¶Ç 1-10)"
                                                    class="bg-gray-700 text-xs text-gray-200 px-2 py-1.5 rounded flex-1 outline-none border border-gray-600 focus:border-blue-500 placeholder-gray-500 transition-colors">

                                                <button @click="handleQuickStart(book)"
                                                    :disabled="book.status === 'processing'"
                                                    class="px-3 py-1.5 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-500 disabled:cursor-not-allowed text-white text-xs rounded transition-colors whitespace-nowrap">
                                                    ‚ñ∂Ô∏è ÂºÄÂßã
                                                </button>
                                            </div>

                                            <div class="flex gap-2">
                                                <button class="mt-2 text-sm text-blue-400 hover:text-blue-300">
                                                    ËøõÂÖ•ËØ¶ÊÉÖ & ÁÆ°ÁêÜ >
                                                </button>
                                            </div>
                                        </div>

                                        <div v-if="books.length === 0"
                                            class="text-center py-12 text-gray-500 bg-gray-800/50 rounded-lg border border-dashed border-gray-700">
                                            ÊöÇÊó†‰π¶Á±çÔºåËØ∑ÂÖà‰∏ä‰º†
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- DETAIL VIEW -->
                            <div v-else class="flex-1 flex flex-col h-full">
                                <!-- Header -->
                                <div
                                    class="bg-gray-800 border-b border-gray-700 p-4 flex justify-between items-center shadow-md z-10">
                                    <div class="flex items-center gap-4">
                                        <button @click="viewMode = 'list'"
                                            class="text-gray-400 hover:text-white p-2 rounded-full hover:bg-gray-700">
                                            ‚Üê ËøîÂõû
                                        </button>
                                        <div>
                                            <h2 class="text-lg font-bold text-white">{{ currentBook.name }}</h2>
                                            <div class="text-xs text-gray-400 flex flex-wrap gap-4 items-center mt-1">
                                                <span>Total: {{ chapters.length }}</span>

                                                <!-- Selected Progress -->
                                                <div class="flex items-center gap-2" v-if="selectedChapters.size > 0">
                                                    <span class="text-blue-400">Selected: {{ selectedChapters.size
                                                        }}</span>
                                                    <div class="w-16 bg-gray-700 rounded-full h-1.5 overflow-hidden">
                                                        <div class="bg-blue-500 h-1.5 rounded-full transition-all duration-500"
                                                            :style="{ width: selectedProgress + '%' }"></div>
                                                    </div>
                                                    <span class="text-blue-400">{{ selectedProgress }}%</span>
                                                </div>
                                                <span v-else>Selected: 0</span>

                                                <span v-if="currentTaskStatus.is_running"
                                                    class="text-green-400 flex items-center gap-1">
                                                    <span class="animate-pulse">‚óè</span> Running
                                                </span>
                                                <span v-else-if="currentTaskStatus.is_paused"
                                                    class="text-yellow-400 flex items-center gap-1">
                                                    <span>‚è∏</span> Paused
                                                </span>
                                            </div>
                                        </div>
                                    </div>

                                    <button @click="openFolder(currentBook.name)"
                                        class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 text-xs rounded transition-colors text-white">
                                        üìÇ ÊâìÂºÄÊñá‰ª∂Â§π
                                    </button>
                                </div>

                                <!-- Sticky Control Bar -->
                                <div
                                    class="bg-gray-800/90 backdrop-blur border-b border-gray-700 p-3 flex items-center gap-4 justify-between sticky top-0 z-10">
                                    <div class="flex items-center gap-2">
                                        <label
                                            class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer hover:text-white select-none">
                                            <input type="checkbox" :checked="isAllSelected" @change="toggleSelectAll"
                                                class="w-4 h-4 rounded border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-700">
                                            ÂÖ®ÈÄâ
                                        </label>
                                        <span class="h-4 w-px bg-gray-600 mx-2"></span>
                                        <button @click="deleteSelected"
                                            :disabled="selectedChapters.size === 0 || currentTaskStatus.is_running"
                                            class="text-xs text-red-400 hover:text-red-300 disabled:text-gray-600 px-2 py-1 rounded hover:bg-gray-700/50 transition-colors">
                                            üóëÔ∏è Ê∏ÖÁêÜÈÄâ‰∏≠
                                        </button>

                                        <!-- Range Selection -->
                                        <div
                                            class="flex items-center bg-gray-700/50 rounded overflow-hidden border border-gray-600 focus-within:ring-1 focus-within:ring-blue-500">
                                            <input type="text" v-model="rangeInput" placeholder="1-5,8"
                                                @keydown.enter="applyRangeSelection"
                                                class="w-20 bg-transparent text-xs text-gray-200 px-2 py-1 outline-none placeholder-gray-500">
                                            <button @click="applyRangeSelection"
                                                class="bg-gray-700 hover:bg-gray-600 text-gray-400 hover:text-white px-2 py-1 text-xs border-l border-gray-600 transition-colors"
                                                title="Â∫îÁî®ËåÉÂõ¥">
                                                ‚úì
                                            </button>
                                        </div>

                                        <!-- Logs Toggle -->
                                        <button @click="showLogs = !showLogs"
                                            class="text-gray-400 hover:text-white p-2 rounded hover:bg-gray-700 transition-colors"
                                            title="Êü•ÁúãÊó•Âøó">
                                            <span class="text-sm">üìú</span>
                                        </button>
                                    </div>

                                    <div class="flex items-center gap-2">
                                        <!-- Start Button -->
                                        <button @click="startSelected"
                                            v-if="!currentTaskStatus.is_running && !currentTaskStatus.is_paused"
                                            :disabled="selectedChapters.size === 0"
                                            class="px-6 py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-500 disabled:cursor-not-allowed text-white text-sm font-medium rounded shadow-lg transition-all flex items-center gap-2">
                                            <span>‚ñ∂Ô∏è</span> ÂºÄÂßãÁîüÊàê ({{ selectedChapters.size }})
                                        </button>

                                        <!-- Pause/Resume Controls -->
                                        <template v-else>
                                            <button @click="pauseTask" v-if="!currentTaskStatus.is_paused"
                                                class="px-6 py-2 bg-yellow-600 hover:bg-yellow-500 text-white text-sm font-medium rounded shadow-lg transition-all flex items-center gap-2">
                                                <span>‚è∏</span> ÊöÇÂÅú
                                            </button>
                                            <button @click="resumeTask" v-else
                                                class="px-6 py-2 bg-green-600 hover:bg-green-500 text-white text-sm font-medium rounded shadow-lg transition-all flex items-center gap-2">
                                                <span>‚ñ∂Ô∏è</span> ÁªßÁª≠
                                            </button>
                                        </template>
                                    </div>
                                </div>

                                <!-- Chapter List -->
                                <div class="flex-1 overflow-y-auto p-4 bg-gray-900">
                                    <div class="space-y-1">
                                        <div v-for="chapter in chapters" :key="chapter.id"
                                            class="flex items-center gap-3 p-3 rounded hover:bg-gray-800 transition-colors border border-transparent hover:border-gray-700 group"
                                            :class="{'bg-gray-800/50': selectedChapters.has(chapter.id)}">

                                            <input type="checkbox" :checked="selectedChapters.has(chapter.id)"
                                                @change="toggleChapter(chapter.id)"
                                                class="w-4 h-4 rounded border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-700 cursor-pointer">

                                            <div class="flex-1 min-w-0">
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-500 font-mono text-xs w-12 text-right">#{{
                                                        chapter.id
                                                        }}</span>
                                                    <span class="text-sm text-gray-200 truncate font-medium">{{
                                                        chapter.title }}</span>
                                                </div>
                                                <div class="flex items-center gap-2 ml-14 mt-1">
                                                    <span class="text-xs text-gray-500">{{ chapter.length }} Â≠ó</span>
                                                    <button @click.stop="previewChapter(chapter)"
                                                        class="text-xs text-blue-500 hover:text-blue-300 flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity"
                                                        title="ËØïÂê¨Ââç20Â≠ó">
                                                        üîä ËØïÂê¨
                                                    </button>
                                                </div>
                                            </div>

                                            <!-- Dynamic Status Icon -->
                                            <div class="w-24 text-right flex justify-end">
                                                <span v-if="chapter.status === 'completed'"
                                                    class="text-green-500 flex items-center gap-1 text-xs">
                                                    ‚úÖ Â∑≤ÂÆåÊàê
                                                </span>
                                                <span v-else-if="chapter.status === 'failed'"
                                                    class="text-red-500 flex items-center gap-1 text-xs">
                                                    ‚ùå Â§±Ë¥•
                                                </span>
                                                <span v-else-if="currentChapterIds.includes(chapter.title)"
                                                    class="text-blue-400 flex items-center gap-1 text-xs animate-pulse">
                                                    ‚è≥ ÁîüÊàê‰∏≠...
                                                </span>
                                                <span v-else class="text-gray-600 text-xs">
                                                    Á≠âÂæÖ‰∏≠
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>

                        <!-- ÁâàÊú¨Êõ¥Êñ∞ÂºπÁ™ó -->
                        <div v-if="showUpdateModal"
                            class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                            @click.self="showUpdateModal = false">
                            <div
                                class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 shadow-2xl border border-gray-700 animate-fade-in">
                                <!-- Ê†áÈ¢ò -->
                                <div class="flex items-center justify-between mb-4">
                                    <h3 class="text-xl font-bold text-white flex items-center gap-2">
                                        <span class="text-2xl">üéâ</span>
                                        <span>ÂèëÁé∞Êñ∞ÁâàÊú¨</span>
                                    </h3>
                                    <button @click="showUpdateModal = false"
                                        class="text-gray-400 hover:text-white transition-colors">
                                        <span class="text-2xl">√ó</span>
                                    </button>
                                </div>

                                <!-- ÂÜÖÂÆπ -->
                                <div v-if="updateInfo" class="space-y-4">
                                    <div class="bg-gray-900 rounded p-4">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="text-gray-400 text-sm">ÂΩìÂâçÁâàÊú¨</span>
                                            <span class="text-white font-mono">{{ updateInfo.current_version }}</span>
                                        </div>
                                        <div class="flex items-center justify-center my-2">
                                            <span class="text-green-400 text-2xl">‚Üì</span>
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <span class="text-gray-400 text-sm">ÊúÄÊñ∞ÁâàÊú¨</span>
                                            <span class="text-green-400 font-mono font-bold">{{
                                                updateInfo.latest_version }}</span>
                                        </div>
                                    </div>

                                    <p class="text-gray-300 text-sm">
                                        <span class="font-semibold">{{ updateInfo.package }}</span>
                                        ÊúâÊñ∞ÁâàÊú¨ÂèØÁî®,Âª∫ËÆÆÊõ¥Êñ∞‰ª•Ëé∑ÂæóÊúÄÊñ∞ÂäüËÉΩÂíå‰øÆÂ§ç„ÄÇ
                                    </p>

                                    <!-- Êõ¥Êñ∞ÂëΩ‰ª§ -->
                                    <div class="bg-gray-900 rounded p-3">
                                        <p class="text-xs text-gray-400 mb-2">Êõ¥Êñ∞ÂëΩ‰ª§:</p>
                                        <code class="text-green-400 text-sm font-mono">
                            pip install --upgrade {{ updateInfo.package }}
                        </code>
                                    </div>
                                </div>

                                <!-- ÊåâÈíÆ -->
                                <div class="flex gap-3 mt-6">
                                    <button @click="dismissUpdate"
                                        class="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded transition-colors">
                                        Á®çÂêéÊèêÈÜí
                                    </button>
                                    <a v-if="updateInfo" :href="`https://pypi.org/project/${updateInfo.package}/`"
                                        target="_blank"
                                        class="flex-1 bg-green-600 hover:bg-green-500 text-white py-2 px-4 rounded text-center transition-colors">
                                        Êü•ÁúãËØ¶ÊÉÖ
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>

                    <script>
                        const { createApp, ref, computed, onMounted, watch, onBeforeUnmount } = Vue;

                        createApp({
                            setup() {
                                // UI State
                                const viewMode = ref('list'); // 'list' | 'detail'
                                const currentBook = ref(null);

                                // Data
                                const books = ref([]);
                                const chapters = ref([]);
                                const selectedChapters = ref(new Set());
                                const voices = ref([]);

                                // Status
                                const currentTaskStatus = ref({ is_running: false, is_paused: false, current_chapter: [] });
                                const currentChapterIds = computed(() => currentTaskStatus.value.current_chapter || []);

                                // Upload
                                const uploading = ref(false);
                                const fileInput = ref(null);

                                // Config
                                const rateVal = ref(0);
                                const volumeVal = ref(0);
                                const pitchVal = ref(0);
                                const concurrency = ref(2);
                                const config = ref({
                                    voice: "zh-CN-XiaoxiaoNeural",
                                    rate: "+0%",
                                    volume: "+0%",
                                    pitch: "+0Hz"
                                });

                                // Bark Notification Config
                                const barkConfig = ref({
                                    serverUrl: "",
                                    apiKey: "",
                                    enabled: false
                                });
                                const barkTesting = ref(false);

                                // Advanced Settings
                                const showAdvanced = ref(false);
                                const showBark = ref(false);
                                const maxRetries = ref(3);
                                const timeout = ref(30);
                                const maxChars = ref(8000);
                                const saving = ref(false);

                                // Config Reload
                                const reloadingConfig = ref(false);
                                const lastReloadTime = ref('');

                                // Version Check
                                const updateInfo = ref(null);
                                const showUpdateModal = ref(false);

                                // Computed
                                watch(rateVal, (val) => config.value.rate = (val >= 0 ? "+" : "") + val + "%"); // Explicitly append % for display/logic if needed, though input handles number
                                watch(volumeVal, (val) => config.value.volume = (val >= 0 ? "+" : "") + val + "%");
                                watch(pitchVal, (val) => config.value.pitch = (val >= 0 ? "+" : "") + val + "Hz");

                                const resetConfig = () => {
                                    rateVal.value = 0;
                                    volumeVal.value = 0;
                                    pitchVal.value = 0;
                                    concurrency.value = 2; // Optional: Reset concurrency too? Keep it separate maybe? Or include it? 
                                    // Let's reset pitch/rate/volume only as they are the main "config" params
                                };

                                const reloadConfig = async () => {
                                    if (reloadingConfig.value) return;

                                    reloadingConfig.value = true;

                                    try {
                                        const res = await api.post('/config/reload');

                                        if (res.data.success) {
                                            // Êõ¥Êñ∞ TTS ÈÖçÁΩÆ
                                            if (res.data.config.tts) {
                                                const tts = res.data.config.tts;

                                                // Êõ¥Êñ∞ËØ≠Èü≥
                                                if (tts.default_voice) {
                                                    config.value.voice = tts.default_voice;
                                                }

                                                // Êõ¥Êñ∞ËØ≠ÈÄü
                                                if (tts.default_rate) {
                                                    const rate = parseInt(tts.default_rate.replace('%', '').replace('+', ''));
                                                    rateVal.value = rate;
                                                }

                                                // Êõ¥Êñ∞Èü≥Èáè
                                                if (tts.default_volume) {
                                                    const volume = parseInt(tts.default_volume.replace('%', '').replace('+', ''));
                                                    volumeVal.value = volume;
                                                }

                                                // Êõ¥Êñ∞Èü≥Ë∞É
                                                if (tts.default_pitch) {
                                                    const pitch = parseInt(tts.default_pitch.replace('Hz', '').replace('+', ''));
                                                    pitchVal.value = pitch;
                                                }

                                                // Êõ¥Êñ∞Âπ∂ÂèëÊï∞
                                                if (tts.concurrency_limit) {
                                                    concurrency.value = tts.concurrency_limit;
                                                }

                                                // Êõ¥Êñ∞È´òÁ∫ßËÆæÁΩÆ
                                                if (tts.max_retries !== undefined) {
                                                    maxRetries.value = tts.max_retries;
                                                }
                                                if (tts.timeout !== undefined) {
                                                    timeout.value = tts.timeout;
                                                }
                                                if (tts.max_chars !== undefined) {
                                                    maxChars.value = tts.max_chars;
                                                }
                                            }

                                            // Êõ¥Êñ∞ Bark ÈÖçÁΩÆ
                                            if (res.data.config.bark) {
                                                const bark = res.data.config.bark;
                                                barkConfig.value.enabled = bark.enabled || false;
                                                barkConfig.value.serverUrl = bark.server_url || '';
                                                barkConfig.value.apiKey = bark.api_key || '';
                                            }

                                            // Êõ¥Êñ∞ËØ≠Èü≥ÂàóË°®
                                            if (res.data.config.voices && res.data.config.voices.length > 0) {
                                                voices.value = res.data.config.voices.map(v => ({
                                                    ShortName: v.short_name,
                                                    Gender: v.gender_cn || v.gender,
                                                    Style: v.style,
                                                    Description: v.description
                                                }));
                                            }

                                            // Êõ¥Êñ∞Êó∂Èó¥Êà≥
                                            lastReloadTime.value = new Date().toLocaleTimeString('zh-CN');

                                            // ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
                                            alert('‚úÖ ' + (res.data.message || 'ÈÖçÁΩÆÂ∑≤‰ªéÁ£ÅÁõòÂêåÊ≠•ÊàêÂäü'));

                                            // Â¶ÇÊûúÊúâÂèòÊõ¥,Âú®ÊéßÂà∂Âè∞ÊòæÁ§∫
                                            if (res.data.changes && Object.keys(res.data.changes).length > 0) {
                                                console.log('[NovelVoice] Config changes:', res.data.changes);
                                            }
                                        }
                                    } catch (error) {
                                        console.error('[NovelVoice] Config reload failed:', error);
                                        const message = error.response?.data?.detail || 'ÈÖçÁΩÆÈáçËΩΩÂ§±Ë¥•';
                                        alert('‚ùå ' + message);
                                    } finally {
                                        reloadingConfig.value = false;
                                    }
                                };

                                const isAllSelected = computed(() => {
                                    return chapters.value.length > 0 && selectedChapters.value.size === chapters.value.length;
                                });

                                const selectedProgress = computed(() => {
                                    if (selectedChapters.value.size === 0) return 0;
                                    const completed = chapters.value.filter(c => selectedChapters.value.has(c.id) && c.status === 'completed').length;
                                    return Math.round((completed / selectedChapters.value.size) * 100);
                                });

                                // API
                                const api = axios.create({ baseURL: '/api' });

                                // --- Methods ---

                                const fetchBooks = async () => {
                                    try {
                                        const res = await api.get('/books');
                                        books.value = res.data;
                                    } catch (e) { console.error(e); }
                                };

                                const fetchVoices = async () => {
                                    const res = await api.get('/voices');
                                    voices.value = res.data;
                                };

                                const updateConcurrency = async () => {
                                    await api.post(`/concurrency?limit=${concurrency.value}`);
                                };

                                // Chapter Management
                                const enterDetail = async (book) => {
                                    currentBook.value = book;
                                    viewMode.value = 'detail';
                                    selectedChapters.value.clear(); // Clear selection on enter? Or keep? Let's clear for now.
                                    await fetchChapters();
                                    await fetchTaskStatus();
                                };

                                const fetchChapters = async () => {
                                    if (!currentBook.value) return;
                                    try {
                                        const res = await api.get(`/chapters/${currentBook.value.name}`);
                                        chapters.value = res.data;
                                    } catch (e) { console.error(e); }
                                };

                                const fetchTaskStatus = async () => {
                                    if (!currentBook.value) return;
                                    try {
                                        const res = await api.get(`/status/${currentBook.value.name}`);
                                        currentTaskStatus.value = res.data;
                                    } catch (e) { }
                                };

                                const toggleChapter = (id) => {
                                    if (selectedChapters.value.has(id)) selectedChapters.value.delete(id);
                                    else selectedChapters.value.add(id);
                                };

                                const toggleSelectAll = () => {
                                    if (isAllSelected.value) {
                                        selectedChapters.value.clear();
                                    } else {
                                        chapters.value.forEach(c => selectedChapters.value.add(c.id));
                                    }
                                };

                                const rangeInput = ref("");
                                const quickRanges = ref({});

                                // Logs
                                const showLogs = ref(false);
                                const logs = ref([]);
                                const logContainer = ref(null);

                                // Auto-scroll logs
                                watch(logs, async () => {
                                    if (showLogs.value && logContainer.value) {
                                        await Vue.nextTick();
                                        logContainer.value.scrollTop = logContainer.value.scrollHeight;
                                    }
                                }, { deep: true });

                                // Auto-fetch logs when opened
                                watch(showLogs, (val) => {
                                    if (val) fetchLogs();
                                });

                                const fetchLogs = async () => {
                                    if (!currentBook.value || !showLogs.value) return;
                                    try {
                                        const res = await api.get(`/logs/${currentBook.value.name}`);
                                        // Only update if length changed or we want to force refresh. 
                                        // To avoid jitter, we could check last log timestamp, but this is simple.
                                        // Actually, just replacing provides latest state.
                                        if (JSON.stringify(res.data.logs) !== JSON.stringify(logs.value)) {
                                            logs.value = res.data.logs;
                                        }
                                    } catch (e) { }
                                };

                                // Validating user input: "1-5, 8, 10-12" to chapter IDs
                                const applyRangeSelection = () => {
                                    const input = rangeInput.value.trim();
                                    selectedChapters.value.clear();

                                    if (!input) {
                                        // Empty -> Select All
                                        toggleSelectAll();
                                        return;
                                    }

                                    const parts = input.split(/[,Ôºå]/); // Support en/cn comma
                                    const allIds = new Set(chapters.value.map(c => c.id));

                                    parts.forEach(part => {
                                        part = part.trim();
                                        if (!part) return;

                                        if (part.includes('-')) {
                                            const [start, end] = part.split('-').map(s => parseInt(s.trim()));
                                            if (!isNaN(start) && !isNaN(end)) {
                                                for (let i = start; i <= end; i++) {
                                                    if (allIds.has(i)) selectedChapters.value.add(i);
                                                }
                                            }
                                        } else {
                                            const id = parseInt(part);
                                            if (!isNaN(id) && allIds.has(id)) {
                                                selectedChapters.value.add(id);
                                            }
                                        }
                                    });
                                };

                                // Quick Start from List View
                                const handleQuickStart = async (book) => {
                                    const rangeStr = quickRanges.value[book.name] || "";
                                    let idsToRun = [];

                                    if (rangeStr.trim()) {
                                        const parts = rangeStr.split(/[,Ôºå]/);
                                        parts.forEach(part => {
                                            part = part.trim();
                                            if (!part) return;
                                            if (part.includes('-')) {
                                                const [start, end] = part.split('-').map(s => parseInt(s.trim()));
                                                if (!isNaN(start) && !isNaN(end)) {
                                                    for (let i = start; i <= end; i++) idsToRun.push(i);
                                                }
                                            } else {
                                                const id = parseInt(part);
                                                if (!isNaN(id)) idsToRun.push(id);
                                            }
                                        });

                                        if (idsToRun.length === 0) {
                                            alert("Êó†ÊïàÁöÑÁ´†ËäÇËåÉÂõ¥Ê†ºÂºè");
                                            return;
                                        }
                                    } else {
                                        if (!confirm(`Êú™ËæìÂÖ•ËåÉÂõ¥ÔºåÁ°ÆÂÆöË¶ÅÁîüÊàê "${book.name}" ÁöÑÂÖ®ÈÉ®Á´†ËäÇÂêóÔºü`)) return;
                                    }

                                    const payload = {
                                        book_name: book.name,
                                        chapter_ids: idsToRun.length > 0 ? idsToRun : undefined,
                                        config: {
                                            voice: config.value.voice,
                                            rate: config.value.rate + "%",
                                            volume: config.value.volume + "%",
                                            pitch: config.value.pitch || "+0Hz"
                                        }
                                    };

                                    try {
                                        await api.post('/start', payload);
                                        fetchBooks();
                                    } catch (e) {
                                        alert("ÂêØÂä®Â§±Ë¥•: " + e.message);
                                    }
                                };

                                // Actions
                                const startSelected = async () => {
                                    // Logic: If selection is empty, default to "Select All" FIRST?
                                    // Or follow the user request "if empty default all". 
                                    // This implies the action itself should select all if nothing is selected.
                                    let idsToRun = Array.from(selectedChapters.value);
                                    if (idsToRun.length === 0) {
                                        if (confirm("Êú™ÈÄâ‰∏≠‰ªª‰ΩïÁ´†ËäÇÔºåÊòØÂê¶ÈªòËÆ§ÁîüÊàêÂÖ®ÈÉ®Á´†ËäÇÔºü")) {
                                            idsToRun = chapters.value.map(c => c.id);
                                            // Optionally update UI selection too
                                            chapters.value.forEach(c => selectedChapters.value.add(c.id));
                                        } else {
                                            return;
                                        }
                                    }

                                    const payload = {
                                        book_name: currentBook.value.name,
                                        chapter_ids: idsToRun,
                                        config: {
                                            voice: config.value.voice,
                                            rate: config.value.rate + "%",
                                            volume: config.value.volume + "%",
                                            pitch: config.value.pitch || "+0Hz"
                                        }
                                    };
                                    try {
                                        await api.post('/start', payload);
                                        fetchTaskStatus();
                                    } catch (e) { alert("ÂêØÂä®Â§±Ë¥•: " + e.message); }
                                };

                                const pauseTask = async () => {
                                    await api.post(`/pause/${currentBook.value.name}`);
                                    fetchTaskStatus();
                                };

                                const resumeTask = async () => {
                                    await api.post(`/resume/${currentBook.value.name}`);
                                    fetchTaskStatus();
                                };

                                const deleteSelected = async () => {
                                    if (!confirm(`Á°ÆÂÆöË¶ÅÊ∏ÖÁêÜÈÄâ‰∏≠ÁöÑ ${selectedChapters.value.size} ‰∏™Á´†ËäÇÂêóÔºüËøô‰ºöÂà†Èô§Â∑≤ÁîüÊàêÁöÑÈü≥È¢ëÊñá‰ª∂„ÄÇ`)) return;

                                    try {
                                        await api.post(`/clean/${currentBook.value.name}`, {
                                            chapter_ids: Array.from(selectedChapters.value)
                                        });
                                        await fetchChapters();
                                        selectedChapters.value.clear();
                                    } catch (e) { alert("Ê∏ÖÁêÜÂ§±Ë¥•: " + e.message); }
                                };

                                // --- Upload ---
                                const handleUpload = async (file) => {
                                    if (!file) return;
                                    uploading.value = true;
                                    const formData = new FormData();
                                    formData.append("file", file);
                                    try {
                                        await api.post('/upload', formData);
                                        await fetchBooks();
                                    } catch (e) {
                                        alert("‰∏ä‰º†Â§±Ë¥•: " + e.response?.data?.detail || e.message);
                                    } finally {
                                        uploading.value = false;
                                    }
                                };
                                const handleFileSelect = (e) => handleUpload(e.target.files[0]);
                                const handleDrop = (e) => handleUpload(e.dataTransfer.files[0]);

                                // --- Helpers ---
                                const openFolder = async (bookName) => {
                                    await api.post(`/open_folder?book_name=${encodeURIComponent(bookName)}`);
                                };

                                // Audio Features
                                const downloadZip = () => {
                                    window.open(`/api/download/${currentBook.value.name}`, '_blank');
                                };

                                const mergeAudio = async () => {
                                    const ids = selectedChapters.value.size > 0 ? Array.from(selectedChapters.value) : null;
                                    const msg = ids ? `Á°ÆÂÆöÂêàÂπ∂ÈÄâ‰∏≠ÁöÑ ${ids.length} ‰∏™Á´†ËäÇÂêóÔºü` : "Á°ÆÂÆöÂêàÂπ∂ÊâÄÊúâÂ∑≤ÂÆåÊàêÁöÑÈü≥È¢ëÂêóÔºü";
                                    if (!confirm(msg)) return;

                                    try {
                                        alert("Ê≠£Âú®ÂêéÂè∞ÂêàÂπ∂ÔºåËØ∑Á®çÂÄô... ÂÆåÊàêÂêéÂ∞ÜËá™Âä®‰∏ãËΩΩ„ÄÇ");
                                        const res = await api.post(`/merge/${currentBook.value.name}`, {
                                            book_name: currentBook.value.name,
                                            chapter_ids: ids,
                                            config: config.value
                                        }, { responseType: 'blob' });

                                        // Download blob
                                        const url = window.URL.createObjectURL(new Blob([res.data]));
                                        const link = document.createElement('a');
                                        link.href = url;
                                        link.setAttribute('download', `${currentBook.value.name}_merged.mp3`);
                                        document.body.appendChild(link);
                                        link.click();
                                    } catch (e) {
                                        alert("ÂêàÂπ∂Â§±Ë¥• (ÂèØËÉΩÊòØÊúçÂä°Âô®Êú™ÂÆâË£Ö ffmpeg): " + (e.response?.data?.detail || e.message));
                                    }
                                };

                                const previewing = ref(false);

                                const testVoice = async () => {
                                    if (previewing.value) return;
                                    previewing.value = true;
                                    try {
                                        const voice = config.value.voice;
                                        const rate = config.value.rate;
                                        const volume = config.value.volume;
                                        const pitch = config.value.pitch;

                                        // Use new GET endpoint with params
                                        const url = `/api/voice/preview/${voice}?rate=${encodeURIComponent(rate)}&volume=${encodeURIComponent(volume)}&pitch=${encodeURIComponent(pitch)}`;

                                        // Play directly from URL
                                        const audio = new Audio(url);
                                        // Add error handling for audio load
                                        audio.onerror = (e) => {
                                            console.error("Audio playback error", e);
                                            alert("ËØïÂê¨Êí≠ÊîæÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÊàñÂêéÁ´ØÊó•Âøó„ÄÇ");
                                            previewing.value = false;
                                        };
                                        audio.onended = () => {
                                            previewing.value = false;
                                        };
                                        await audio.play();
                                    } catch (e) {
                                        console.error("Voice test failed:", e);
                                        alert("ËØïÂê¨ËØ∑Ê±ÇÂ§±Ë¥•: " + e.message);
                                        previewing.value = false;
                                    }
                                    // Note: previewing set to false in onended/onerror
                                };

                                // Custom Preview Logic
                                const customText = ref("");
                                const customPreviewing = ref(false);

                                const defaultCustomPlaceholder = computed(() => {
                                    const v = voices.value.find(v => v.ShortName === config.value.voice);
                                    const name = v ? (v.LocalName || v.ShortName.split('-').pop().replace('Neural', '')) : "Êàë";
                                    return `‰Ω†Â•ΩÔºåÊàëÊòØ${name}ÔºåÊÇ®ÂèØ‰ª•ËæìÂÖ•ÊñáÂ≠óËÆ©ÊàëËØïËØª„ÄÇ`;
                                });

                                const randomTexts = [
                                    "Â§©Ë°óÂ∞èÈõ®Ê∂¶Â¶ÇÈÖ•ÔºåËçâËâ≤ÈÅ•ÁúãËøëÂç¥Êó†„ÄÇ",
                                    "ÊçÆÊúÄÊñ∞Ê∂àÊÅØÔºåÂæÆËΩØÂèëÂ∏É‰∫ÜÊñ∞‰∏Ä‰ª£‰∫∫Â∑•Êô∫ËÉΩËØ≠Èü≥ÊäÄÊúØÔºåÊïàÊûúÊÉä‰∫∫„ÄÇ",
                                    "‰Ω†Ëã•ÊòØÈÇ£Âê´Ê≥™ÁöÑÂ∞ÑÊâãÔºåÊàë‰æøÊòØÈÇ£ÂÜ≥ÂøÉ‰∏çÂÜçÈó™Ë∫≤ÁöÑÁôΩÈ∏ü„ÄÇ",
                                    "‰ªäÂ§©Â§©Ê∞îÁúü‰∏çÈîôÔºåÈÄÇÂêàÂá∫ÂéªËµ∞Ëµ∞ÔºåÂñùÊùØÂíñÂï°„ÄÇ",
                                    "ÁîüÊ¥ª‰∏çÊòØÁúºÂâçÁöÑËãü‰∏îÔºåËøòÊúâËØóÂíåËøúÊñπÁöÑÁî∞Èáé„ÄÇ"
                                ];

                                const setRandomText = () => {
                                    customText.value = randomTexts[Math.floor(Math.random() * randomTexts.length)];
                                };

                                const testCustomVoice = async () => {
                                    if (!customText.value) return;
                                    if (customPreviewing.value) return;

                                    customPreviewing.value = true;
                                    try {
                                        const res = await api.post('/voice/preview_custom', {
                                            text: customText.value,
                                            voice: config.value.voice,
                                            rate: config.value.rate,
                                            volume: config.value.volume,
                                            pitch: config.value.pitch
                                        }, { responseType: 'blob' });

                                        const blob = new Blob([res.data], { type: 'audio/mpeg' });
                                        const url = URL.createObjectURL(blob);
                                        const audio = new Audio(url);

                                        audio.onended = () => {
                                            URL.revokeObjectURL(url);
                                            customPreviewing.value = false;
                                        };
                                        audio.onerror = () => {
                                            alert("Êí≠ÊîæÂ§±Ë¥•");
                                            customPreviewing.value = false;
                                        }
                                        await audio.play();
                                    } catch (e) {
                                        alert("ÁîüÊàêÂ§±Ë¥•: " + (e.response?.data?.detail || e.message));
                                        customPreviewing.value = false;
                                    }
                                };

                                const previewChapter = async (chapter) => {
                                    try {
                                        // Show loading state on button? Hard with current iterate.
                                        // Just use global generic loading or toast?
                                        // For now simple alert if slow?
                                        console.log("Previewing chapter:", chapter.title);
                                        // Fix: pass correct book_name and chapter_id to backend.
                                        // Backend logic: if book_name != "preview" and chapter_id present, it fetches content.
                                        const res = await api.post('/preview', {
                                            book_name: currentBook.value.name,
                                            chapter_id: chapter.id,
                                            config: {
                                                ...config.value,
                                                rate: config.value.rate + "%",
                                                volume: config.value.volume + "%",
                                                pitch: config.value.pitch || "+0Hz"
                                            }
                                        }, { responseType: 'blob' });

                                        const blob = new Blob([res.data], { type: 'audio/mpeg' });
                                        const audio = new Audio(URL.createObjectURL(blob));
                                        await audio.play();
                                    } catch (e) {
                                        console.error("Preview failed:", e);
                                        alert("ËØïÂê¨Â§±Ë¥•: " + e.message);
                                    }
                                };

                                // Bark Notification Test
                                const testBarkNotification = async () => {
                                    if (!barkConfig.value.serverUrl || !barkConfig.value.apiKey) {
                                        alert("ËØ∑ÂÖàÂ°´ÂÜô Bark ÊúçÂä°Âô®Âú∞ÂùÄÂíå Key");
                                        return;
                                    }

                                    barkTesting.value = true;
                                    try {
                                        const res = await api.post('/bark/test', {
                                            server_url: barkConfig.value.serverUrl,
                                            api_key: barkConfig.value.apiKey
                                        });

                                        if (res.data.success) {
                                            alert("‚úÖ " + res.data.message);
                                        } else {
                                            alert("‚ùå " + res.data.message);
                                        }
                                    } catch (e) {
                                        console.error("Bark test failed:", e);
                                        alert("ÊµãËØïÂ§±Ë¥•: " + (e.response?.data?.detail || e.message));
                                    } finally {
                                        barkTesting.value = false;
                                    }
                                };

                                // Notifications
                                const requestNotification = () => {
                                    if ("Notification" in window && Notification.permission !== "granted") {
                                        Notification.requestPermission();
                                    }
                                };

                                // Watch status for notifications
                                watch(() => currentTaskStatus.value, (newVal, oldVal) => {
                                    if (oldVal.is_running && !newVal.is_running) {
                                        // Finished?
                                        // Check if all completed or any failed? 
                                        // Simplified: Just notify "Task Stopped/Finished"
                                        if (Notification.permission === "granted") {
                                            new Notification("Edge TTS", { body: `‰ªªÂä°Â∑≤Â∑≤ÂÅúÊ≠¢ÊàñÂÆåÊàê: ${currentBook.value?.name}` });
                                        }
                                    }
                                }, { deep: true });

                                // Watch concurrency
                                watch(concurrency, async (newVal) => {
                                    try {
                                        await api.post(`/concurrency?limit=${newVal}`);
                                    } catch (e) { console.error(e); }
                                });

                                const statusClass = (status) => {
                                    switch (status) {
                                        case 'completed': return 'bg-green-900 text-green-300';
                                        case 'processing': return 'bg-blue-900 text-blue-300 animate-pulse';
                                        default: return 'bg-gray-700 text-gray-300';
                                    }
                                };

                                const progressPercent = (book) => {
                                    if (book.total === 0) return 0;
                                    return Math.round((book.completed / book.total) * 100);
                                };

                                // ==================== ÈÖçÁΩÆÂä†ËΩΩÂíå‰øùÂ≠ò ====================

                                // Version Check Methods
                                const checkVersion = async () => {
                                    try {
                                        const res = await api.get('/version/info');
                                        if (res.data.update_available && res.data.update_info) {
                                            updateInfo.value = res.data.update_info;
                                            showUpdateModal.value = true;
                                        }
                                    } catch (e) {
                                        console.error('ÁâàÊú¨Ê£ÄÊü•Â§±Ë¥•:', e);
                                    }
                                };

                                const dismissUpdate = async () => {
                                    try {
                                        await api.post('/version/dismiss');
                                        showUpdateModal.value = false;
                                        updateInfo.value = null;
                                    } catch (e) {
                                        console.error('ÂøΩÁï•Êõ¥Êñ∞Â§±Ë¥•:', e);
                                    }
                                };

                                const loadConfigFromBackend = async () => {
                                    try {
                                        const res = await api.get('/config');
                                        if (res.data.success && res.data.config) {
                                            const cfg = res.data.config;

                                            // TTS ÈÖçÁΩÆ
                                            if (cfg.tts) {
                                                if (cfg.tts.default_voice) config.value.voice = cfg.tts.default_voice;
                                                if (cfg.tts.default_rate) {
                                                    rateVal.value = parseInt(cfg.tts.default_rate.replace('%', '').replace('+', ''));
                                                }
                                                if (cfg.tts.default_volume) {
                                                    volumeVal.value = parseInt(cfg.tts.default_volume.replace('%', '').replace('+', ''));
                                                }
                                                if (cfg.tts.default_pitch) {
                                                    pitchVal.value = parseInt(cfg.tts.default_pitch.replace('Hz', '').replace('+', ''));
                                                }
                                                if (cfg.tts.concurrency_limit) concurrency.value = cfg.tts.concurrency_limit;
                                                if (cfg.tts.max_retries) maxRetries.value = cfg.tts.max_retries;
                                                if (cfg.tts.timeout) timeout.value = cfg.tts.timeout;
                                                if (cfg.tts.max_chars) maxChars.value = cfg.tts.max_chars;
                                            }

                                            // Bark ÈÖçÁΩÆ
                                            if (cfg.bark) {
                                                if (cfg.bark.server_url) barkConfig.value.serverUrl = cfg.bark.server_url;
                                                if (cfg.bark.api_key) barkConfig.value.apiKey = cfg.bark.api_key;
                                                if (cfg.bark.enabled !== undefined) barkConfig.value.enabled = cfg.bark.enabled;
                                            }

                                            console.log('‚úÖ ÈÖçÁΩÆÂ∑≤‰ªéÂêéÁ´ØÂä†ËΩΩ');
                                        }
                                    } catch (e) {
                                        console.error('Âä†ËΩΩÈÖçÁΩÆÂ§±Ë¥•:', e);
                                    }
                                };

                                const saveAsDefault = async () => {
                                    if (!confirm('Á°ÆÂÆöÂ∞ÜÂΩìÂâçËÆæÁΩÆ‰øùÂ≠ò‰∏∫ÈªòËÆ§ÈÖçÁΩÆÂêó?\n\n‰øùÂ≠òÂêé,‰∏ãÊ¨°ÂêØÂä®Â∫îÁî®Â∞Ü‰ΩøÁî®Ëøô‰∫õÂèÇÊï∞‰Ωú‰∏∫ÈªòËÆ§ÂÄº„ÄÇ')) {
                                        return;
                                    }

                                    saving.value = true;
                                    try {
                                        const payload = {
                                            tts: {
                                                default_voice: config.value.voice,
                                                default_rate: config.value.rate,
                                                default_volume: config.value.volume,
                                                default_pitch: config.value.pitch,
                                                concurrency_limit: parseInt(concurrency.value),
                                                max_retries: parseInt(maxRetries.value),
                                                timeout: parseInt(timeout.value),
                                                max_chars: parseInt(maxChars.value)
                                            },
                                            bark: {
                                                enabled: barkConfig.value.enabled,
                                                server_url: barkConfig.value.serverUrl,
                                                api_key: barkConfig.value.apiKey
                                            }
                                        };

                                        const res = await api.post('/config', payload);

                                        if (res.data.success) {
                                            alert('‚úÖ ÈÖçÁΩÆÂ∑≤‰øùÂ≠ò!\n\n' + res.data.message);
                                        } else {
                                            alert('‚ùå ‰øùÂ≠òÂ§±Ë¥•: ' + (res.data.message || 'Êú™Áü•ÈîôËØØ'));
                                        }
                                    } catch (e) {
                                        console.error('‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•:', e);
                                        let errorMsg = '‰øùÂ≠òÂ§±Ë¥•';
                                        if (e.response?.data?.detail) {
                                            if (typeof e.response.data.detail === 'object') {
                                                // È™åËØÅÈîôËØØ
                                                const errors = e.response.data.detail.errors || {};
                                                errorMsg = 'ÂèÇÊï∞È™åËØÅÂ§±Ë¥•:\n\n';
                                                for (const [field, msg] of Object.entries(errors)) {
                                                    errorMsg += `- ${field}: ${msg}\n`;
                                                }
                                            } else {
                                                errorMsg = e.response.data.detail;
                                            }
                                        }
                                        alert('‚ùå ' + errorMsg);
                                    } finally {
                                        saving.value = false;
                                    }
                                };

                                // Lifecycle
                                let pollTimer;
                                const startPolling = () => {
                                    pollTimer = setInterval(() => {
                                        if (viewMode.value === 'list') {
                                            fetchBooks();
                                        } else {
                                            fetchChapters();
                                            fetchTaskStatus();
                                            fetchLogs();
                                        }
                                    }, 2000);
                                };

                                onMounted(async () => {
                                    await loadConfigFromBackend();
                                    await fetchBooks();
                                    await fetchVoices();
                                    startPolling();

                                    // Âª∂ËøüÊ£ÄÊü•ÁâàÊú¨Êõ¥Êñ∞
                                    setTimeout(checkVersion, 3000);
                                });

                                onBeforeUnmount(() => {
                                    clearInterval(pollTimer);
                                });

                                return {
                                    // State
                                    viewMode, currentBook, books, chapters, selectedChapters, voices,
                                    currentTaskStatus, currentChapterIds,
                                    uploading, fileInput,
                                    rateVal, volumeVal, pitchVal, concurrency, config,
                                    barkConfig, barkTesting,
                                    showAdvanced, maxRetries, timeout, maxChars, saving,
                                    reloadingConfig, lastReloadTime,
                                    updateInfo, showUpdateModal,
                                    isAllSelected, rangeInput, quickRanges,
                                    showLogs, logs, logContainer,
                                    customText, customPreviewing, defaultCustomPlaceholder, previewing,

                                    // Methods
                                    fetchBooks, fetchVoices, updateConcurrency, fetchLogs,
                                    enterDetail, fetchChapters, fetchTaskStatus,
                                    handleUpload, handleFileSelect, handleDrop,
                                    toggleChapter, toggleSelectAll, applyRangeSelection, handleQuickStart,
                                    deleteSelected, startSelected, pauseTask, resumeTask,
                                    resetConfig, reloadConfig,
                                    testVoice, previewChapter, testCustomVoice, setRandomText,
                                    downloadZip, mergeAudio, openFolder,
                                    testBarkNotification, saveAsDefault, loadConfigFromBackend,
                                    checkVersion, dismissUpdate,
                                    statusClass, progressPercent
                                };
                            }
                        }).mount('#app');
                    </script>
</body>

</html>